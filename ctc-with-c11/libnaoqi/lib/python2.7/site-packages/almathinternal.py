# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.5
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_almathinternal', [dirname(__file__)])
        except ImportError:
            import _almathinternal
            return _almathinternal
        if fp is not None:
            try:
                _mod = imp.load_module('_almathinternal', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _almathinternal = swig_import_helper()
    del swig_import_helper
else:
    import _almathinternal
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


import almathswig
class Segment(_object):
    """Proxy of C++ AL::Math::Segment class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Segment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Segment, name)
    __repr__ = _swig_repr
    __swig_setmethods__["start"] = _almathinternal.Segment_start_set
    __swig_getmethods__["start"] = _almathinternal.Segment_start_get
    if _newclass:
        start = _swig_property(_almathinternal.Segment_start_get, _almathinternal.Segment_start_set)
    __swig_setmethods__["end"] = _almathinternal.Segment_end_set
    __swig_getmethods__["end"] = _almathinternal.Segment_end_get
    if _newclass:
        end = _swig_property(_almathinternal.Segment_end_get, _almathinternal.Segment_end_set)

    def __init__(self, *args):
        """
        __init__(AL::Math::Segment self) -> Segment
        __init__(AL::Math::Segment self, Position2D pStart, Position2D pEnd) -> Segment
        """
        this = _almathinternal.new_Segment(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _almathinternal.delete_Segment
    __del__ = lambda self: None
Segment_swigregister = _almathinternal.Segment_swigregister
Segment_swigregister(Segment)


def isIndexInList(pk, pList):
    """isIndexInList(unsigned short pk, std::vector< unsigned short,std::allocator< unsigned short > > pList) -> bool"""
    return _almathinternal.isIndexInList(pk, pList)

def sortPredicate(p1, p2):
    """sortPredicate(Position2D p1, Position2D p2) -> bool"""
    return _almathinternal.sortPredicate(p1, p2)

def removeAlignedPoint(pPoints, pOut):
    """removeAlignedPoint(vectorPosition2D pPoints, vectorPosition2D pOut)"""
    return _almathinternal.removeAlignedPoint(pPoints, pOut)

def deleteDupesInUnsortedVector(pPoints, pEps=0.0001):
    """
    deleteDupesInUnsortedVector(vectorPosition2D pPoints, float const pEps=0.0001)
    deleteDupesInUnsortedVector(vectorPosition2D pPoints)
    """
    return _almathinternal.deleteDupesInUnsortedVector(pPoints, pEps)

def deleteDupesInSortedVector(pPoints, pEps=0.0001):
    """
    deleteDupesInSortedVector(vectorPosition2D pPoints, float const pEps=0.0001)
    deleteDupesInSortedVector(vectorPosition2D pPoints)
    """
    return _almathinternal.deleteDupesInSortedVector(pPoints, pEps)

def isLeft(*args):
    """
    isLeft(Position2D pA, Position2D pB, Position2D pC, float const & pEps=0.00001) -> int
    isLeft(Position2D pA, Position2D pB, Position2D pC) -> int
    isLeft(Position3D pDirection, Position3D pA, Position3D pB, Position3D pC, float const & pEps=0.00001) -> int
    isLeft(Position3D pDirection, Position3D pA, Position3D pB, Position3D pC) -> int
    """
    return _almathinternal.isLeft(*args)

def isLeftBest(pA, pB, pC):
    """isLeftBest(Position2D pA, Position2D pB, Position2D pC) -> int"""
    return _almathinternal.isLeftBest(pA, pB, pC)

def isLeftOld(pA, pB, pC, pEps=0.000001):
    """
    isLeftOld(Position2D pA, Position2D pB, Position2D pC, float const & pEps=0.000001) -> int
    isLeftOld(Position2D pA, Position2D pB, Position2D pC) -> int
    """
    return _almathinternal.isLeftOld(pA, pB, pC, pEps)

def simplifyConvexHull(pConvexHull):
    """simplifyConvexHull(vectorPosition2D pConvexHull)"""
    return _almathinternal.simplifyConvexHull(pConvexHull)

def getConvexHull(pPoints):
    """getConvexHull(vectorPosition2D pPoints) -> vectorPosition2D"""
    return _almathinternal.getConvexHull(pPoints)

def getConvexHullGraham(pPoints):
    """getConvexHullGraham(vectorPosition2D pPoints) -> vectorPosition2D"""
    return _almathinternal.getConvexHullGraham(pPoints)

def computePointProjectionOnEdge(pPoint, pSegmentOrigin, pSegmentEnd, pProportion, pProjection):
    """computePointProjectionOnEdge(Position2D pPoint, Position2D pSegmentOrigin, Position2D pSegmentEnd, float & pProportion, Position2D pProjection)"""
    return _almathinternal.computePointProjectionOnEdge(pPoint, pSegmentOrigin, pSegmentEnd, pProportion, pProjection)

def computePointProjectionOnConvexHull(pPoint, pConvexHull):
    """computePointProjectionOnConvexHull(Position2D pPoint, vectorPosition2D pConvexHull) -> Position2D"""
    return _almathinternal.computePointProjectionOnConvexHull(pPoint, pConvexHull)

def computePolygonCentroid(pPolygon):
    """computePolygonCentroid(vectorPosition2D pPolygon) -> Position2D"""
    return _almathinternal.computePolygonCentroid(pPolygon)

def scaleConvexHullInPlace(pConvexHull, pScaleFactor):
    """scaleConvexHullInPlace(vectorPosition2D pConvexHull, float pScaleFactor)"""
    return _almathinternal.scaleConvexHullInPlace(pConvexHull, pScaleFactor)

def scaleConvexHull(pConvexHull, pScaleFactor, pConvexHullScaled):
    """scaleConvexHull(vectorPosition2D pConvexHull, float pScaleFactor, vectorPosition2D pConvexHullScaled)"""
    return _almathinternal.scaleConvexHull(pConvexHull, pScaleFactor, pConvexHullScaled)

def discretizedCircle(*args):
    """
    discretizedCircle(Pose2D pCenter, float pRadius, unsigned int pNumberVertice, vectorPosition2D pResult)
    discretizedCircle(Pose2D pCenter, float pRadius, unsigned int pNumberVertice) -> vectorPosition2D
    discretizedCircle(Pose2D pCenter, float pRadius, unsigned int pNumberVertice, std::vector< AL::Math::Position2D,std::allocator< AL::Math::Position2D > >::iterator pOutput) -> std::vector< AL::Math::Position2D,std::allocator< AL::Math::Position2D > >::iterator
    discretizedCircle(Pose2D pCenter, float pRadiusX, float pRadiusY, unsigned int pNumberVertice, vectorPosition2D pResult)
    discretizedCircle(Pose2D pCenter, float pRadiusX, float pRadiusY, unsigned int pNumberVertice) -> vectorPosition2D
    discretizedCircle(Pose2D pCenter, float pRadiusX, float pRadiusY, unsigned int pNumberVertice, std::vector< AL::Math::Position2D,std::allocator< AL::Math::Position2D > >::iterator pOutput) -> std::vector< AL::Math::Position2D,std::allocator< AL::Math::Position2D > >::iterator
    """
    return _almathinternal.discretizedCircle(*args)
class VelocitySaturationProfile(_object):
    """Proxy of C++ AL::Math::VelocitySaturationProfile class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VelocitySaturationProfile, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VelocitySaturationProfile, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(AL::Math::VelocitySaturationProfile self) -> VelocitySaturationProfile"""
        this = _almathinternal.new_VelocitySaturationProfile()
        try:
            self.this.append(this)
        except:
            self.this = this

    def init(self, pX0, pX1, pX2, pX3, pY0, pY1, pY2):
        """init(VelocitySaturationProfile self, float pX0, float pX1, float pX2, float pX3, float pY0, float pY1, float pY2)"""
        return _almathinternal.VelocitySaturationProfile_init(self, pX0, pX1, pX2, pX3, pY0, pY1, pY2)


    def get(self, pX):
        """get(VelocitySaturationProfile self, float pX) -> float"""
        return _almathinternal.VelocitySaturationProfile_get(self, pX)

    __swig_destroy__ = _almathinternal.delete_VelocitySaturationProfile
    __del__ = lambda self: None
VelocitySaturationProfile_swigregister = _almathinternal.VelocitySaturationProfile_swigregister
VelocitySaturationProfile_swigregister(VelocitySaturationProfile)

class VelocitySaturationProfile2D(_object):
    """Proxy of C++ AL::Math::VelocitySaturationProfile2D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VelocitySaturationProfile2D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VelocitySaturationProfile2D, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(AL::Math::VelocitySaturationProfile2D self) -> VelocitySaturationProfile2D"""
        this = _almathinternal.new_VelocitySaturationProfile2D()
        try:
            self.this.append(this)
        except:
            self.this = this

    def init(self, pR0, pR1, pR2, pR3, pTheta0, pTheta1, pY0, pY1, pY2):
        """init(VelocitySaturationProfile2D self, float pR0, float pR1, float pR2, float pR3, float pTheta0, float pTheta1, float pY0, float pY1, float pY2)"""
        return _almathinternal.VelocitySaturationProfile2D_init(self, pR0, pR1, pR2, pR3, pTheta0, pTheta1, pY0, pY1, pY2)


    def __call__(self, pPos):
        """__call__(VelocitySaturationProfile2D self, Position2D pPos) -> float"""
        return _almathinternal.VelocitySaturationProfile2D___call__(self, pPos)

    __swig_destroy__ = _almathinternal.delete_VelocitySaturationProfile2D
    __del__ = lambda self: None
VelocitySaturationProfile2D_swigregister = _almathinternal.VelocitySaturationProfile2D_swigregister
VelocitySaturationProfile2D_swigregister(VelocitySaturationProfile2D)


_almathinternal.TRACKER_BASIC_swigconstant(_almathinternal)
TRACKER_BASIC = _almathinternal.TRACKER_BASIC

_almathinternal.TRACKER_TYPEIV_swigconstant(_almathinternal)
TRACKER_TYPEIV = _almathinternal.TRACKER_TYPEIV

_almathinternal.TRACKER_QUINTICSPLINE_swigconstant(_almathinternal)
TRACKER_QUINTICSPLINE = _almathinternal.TRACKER_QUINTICSPLINE

_almathinternal.TRACKER_ERRORCOMPENSATION_swigconstant(_almathinternal)
TRACKER_ERRORCOMPENSATION = _almathinternal.TRACKER_ERRORCOMPENSATION

_almathinternal.TRACKER_PREVIEWTRAJECTORY_swigconstant(_almathinternal)
TRACKER_PREVIEWTRAJECTORY = _almathinternal.TRACKER_PREVIEWTRAJECTORY

_almathinternal.TRACKER_ALL_swigconstant(_almathinternal)
TRACKER_ALL = _almathinternal.TRACKER_ALL

_almathinternal.TRACKER_NUMBER_OF_TYPE_swigconstant(_almathinternal)
TRACKER_NUMBER_OF_TYPE = _almathinternal.TRACKER_NUMBER_OF_TYPE
class AnticipationTracker(_object):
    """Proxy of C++ AL::Math::AnticipationTracker class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AnticipationTracker, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AnticipationTracker, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AL::Math::AnticipationTracker self) -> AnticipationTracker
        __init__(AL::Math::AnticipationTracker self, AL::Math::TRACKER_TYPE const & pTrackerState, float const & pPeriod, float const & pVelocityMaxAbs, float const & pAccelerationMaxAbs, float const & pJerkMaxAbs, unsigned int const & pPolynomDegree, unsigned int const & pNbSample, float const & pTimeDamping) -> AnticipationTracker
        """
        this = _almathinternal.new_AnticipationTracker(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def init(self, pCurrentAngle):
        """init(AnticipationTracker self, float const & pCurrentAngle)"""
        return _almathinternal.AnticipationTracker_init(self, pCurrentAngle)


    def update(self, pTargetTime, pTargetAngle):
        """update(AnticipationTracker self, float const & pTargetTime, float const & pTargetAngle)"""
        return _almathinternal.AnticipationTracker_update(self, pTargetTime, pTargetAngle)


    def getResultInterpolation(self, pTime, pOut):
        """getResultInterpolation(AnticipationTracker self, float const & pTime, PositionAndVelocity pOut)"""
        return _almathinternal.AnticipationTracker_getResultInterpolation(self, pTime, pOut)


    def getResultPosition(self, pTime):
        """getResultPosition(AnticipationTracker self, float const & pTime) -> float"""
        return _almathinternal.AnticipationTracker_getResultPosition(self, pTime)


    def getResultVelocity(self, pTime):
        """getResultVelocity(AnticipationTracker self, float const & pTime) -> float"""
        return _almathinternal.AnticipationTracker_getResultVelocity(self, pTime)


    def getResultAcceleration(self, pTime):
        """getResultAcceleration(AnticipationTracker self, float const & pTime) -> float"""
        return _almathinternal.AnticipationTracker_getResultAcceleration(self, pTime)


    def printInfo(self):
        """printInfo(AnticipationTracker self) -> std::string"""
        return _almathinternal.AnticipationTracker_printInfo(self)

    __swig_destroy__ = _almathinternal.delete_AnticipationTracker
    __del__ = lambda self: None
AnticipationTracker_swigregister = _almathinternal.AnticipationTracker_swigregister
AnticipationTracker_swigregister(AnticipationTracker)

class OpenLoopFeedBack(_object):
    """Proxy of C++ AL::Math::OpenLoopFeedBack class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OpenLoopFeedBack, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OpenLoopFeedBack, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AL::Math::OpenLoopFeedBack self) -> OpenLoopFeedBack
        __init__(AL::Math::OpenLoopFeedBack self, float const & pPeriod, float const & pVelocityMaxAbs) -> OpenLoopFeedBack
        """
        this = _almathinternal.new_OpenLoopFeedBack(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update(self, pTargetTime, pTargetAngle):
        """update(OpenLoopFeedBack self, float const & pTargetTime, float const & pTargetAngle)"""
        return _almathinternal.OpenLoopFeedBack_update(self, pTargetTime, pTargetAngle)


    def getResultInterpolation(self, pTime, pOut):
        """getResultInterpolation(OpenLoopFeedBack self, float const & pTime, PositionAndVelocity pOut)"""
        return _almathinternal.OpenLoopFeedBack_getResultInterpolation(self, pTime, pOut)


    def getResultPosition(self, pTime):
        """getResultPosition(OpenLoopFeedBack self, float const & pTime) -> float"""
        return _almathinternal.OpenLoopFeedBack_getResultPosition(self, pTime)


    def getResultVelocity(self, pTime):
        """getResultVelocity(OpenLoopFeedBack self, float const & pTime) -> float"""
        return _almathinternal.OpenLoopFeedBack_getResultVelocity(self, pTime)

    __swig_destroy__ = _almathinternal.delete_OpenLoopFeedBack
    __del__ = lambda self: None
OpenLoopFeedBack_swigregister = _almathinternal.OpenLoopFeedBack_swigregister
OpenLoopFeedBack_swigregister(OpenLoopFeedBack)

class ALNormalizeData(_object):
    """Proxy of C++ AL::Math::ALNormalizeData class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALNormalizeData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALNormalizeData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AL::Math::ALNormalizeData self) -> ALNormalizeData
        __init__(AL::Math::ALNormalizeData self, ALNormalizeData pOther) -> ALNormalizeData
        __init__(AL::Math::ALNormalizeData self, unsigned int const & pNbSample) -> ALNormalizeData
        """
        this = _almathinternal.new_ALNormalizeData(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update(self, pData):
        """update(ALNormalizeData self, float const & pData)"""
        return _almathinternal.ALNormalizeData_update(self, pData)


    def getDataBasic(self, pIdx):
        """getDataBasic(ALNormalizeData self, unsigned int const & pIdx) -> float"""
        return _almathinternal.ALNormalizeData_getDataBasic(self, pIdx)


    def getDataNormalized(self, pIdx):
        """getDataNormalized(ALNormalizeData self, unsigned int const & pIdx) -> float"""
        return _almathinternal.ALNormalizeData_getDataNormalized(self, pIdx)


    def printData(self):
        """printData(ALNormalizeData self) -> std::string"""
        return _almathinternal.ALNormalizeData_printData(self)

    __swig_destroy__ = _almathinternal.delete_ALNormalizeData
    __del__ = lambda self: None
ALNormalizeData_swigregister = _almathinternal.ALNormalizeData_swigregister
ALNormalizeData_swigregister(ALNormalizeData)

class PreviewTrajectory(_object):
    """Proxy of C++ AL::Math::PreviewTrajectory class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PreviewTrajectory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PreviewTrajectory, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AL::Math::PreviewTrajectory self) -> PreviewTrajectory
        __init__(AL::Math::PreviewTrajectory self, unsigned int const & pPolynomDegree, unsigned int const & pNbSample, float const & pTimeDamping) -> PreviewTrajectory
        """
        this = _almathinternal.new_PreviewTrajectory(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update(self, pTargetTime, pTargetAngle):
        """update(PreviewTrajectory self, float const & pTargetTime, float const & pTargetAngle)"""
        return _almathinternal.PreviewTrajectory_update(self, pTargetTime, pTargetAngle)


    def getResultInterpolation(self, pTime, pUseDamping, pOut):
        """getResultInterpolation(PreviewTrajectory self, float const & pTime, bool pUseDamping, PositionAndVelocity pOut)"""
        return _almathinternal.PreviewTrajectory_getResultInterpolation(self, pTime, pUseDamping, pOut)


    def getResultPosVelAcc(self, pTime, pUseDamping):
        """getResultPosVelAcc(PreviewTrajectory self, float const & pTime, bool pUseDamping) -> PosVelAcc"""
        return _almathinternal.PreviewTrajectory_getResultPosVelAcc(self, pTime, pUseDamping)


    def getResultPosition(self, pTime, pUseDamping):
        """getResultPosition(PreviewTrajectory self, float const & pTime, bool pUseDamping) -> float"""
        return _almathinternal.PreviewTrajectory_getResultPosition(self, pTime, pUseDamping)


    def getResultVelocity(self, pTime, pUseDamping):
        """getResultVelocity(PreviewTrajectory self, float const & pTime, bool pUseDamping) -> float"""
        return _almathinternal.PreviewTrajectory_getResultVelocity(self, pTime, pUseDamping)


    def getResultAcceleration(self, pTime, pUseDamping):
        """getResultAcceleration(PreviewTrajectory self, float const & pTime, bool pUseDamping) -> float"""
        return _almathinternal.PreviewTrajectory_getResultAcceleration(self, pTime, pUseDamping)


    def getInfo(self, pIdx):
        """getInfo(PreviewTrajectory self, unsigned int const & pIdx) -> PositionAndVelocity"""
        return _almathinternal.PreviewTrajectory_getInfo(self, pIdx)


    def printSolution(self):
        """printSolution(PreviewTrajectory self) -> std::string"""
        return _almathinternal.PreviewTrajectory_printSolution(self)


    def printInfo(self):
        """printInfo(PreviewTrajectory self) -> std::string"""
        return _almathinternal.PreviewTrajectory_printInfo(self)

    __swig_destroy__ = _almathinternal.delete_PreviewTrajectory
    __del__ = lambda self: None
PreviewTrajectory_swigregister = _almathinternal.PreviewTrajectory_swigregister
PreviewTrajectory_swigregister(PreviewTrajectory)

class LowPassFilter(_object):
    """Proxy of C++ AL::Math::LowPassFilter class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LowPassFilter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LowPassFilter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AL::Math::LowPassFilter self) -> LowPassFilter
        __init__(AL::Math::LowPassFilter self, float const & pPeriodSample, float const & pFrequency) -> LowPassFilter
        """
        this = _almathinternal.new_LowPassFilter(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def update(self, pTargetAngle):
        """update(LowPassFilter self, float const & pTargetAngle)"""
        return _almathinternal.LowPassFilter_update(self, pTargetAngle)


    def getResult(self):
        """getResult(LowPassFilter self) -> float"""
        return _almathinternal.LowPassFilter_getResult(self)

    __swig_destroy__ = _almathinternal.delete_LowPassFilter
    __del__ = lambda self: None
LowPassFilter_swigregister = _almathinternal.LowPassFilter_swigregister
LowPassFilter_swigregister(LowPassFilter)


_almathinternal.CONSTANT_swigconstant(_almathinternal)
CONSTANT = _almathinternal.CONSTANT

_almathinternal.LINEAR_swigconstant(_almathinternal)
LINEAR = _almathinternal.LINEAR

_almathinternal.BEZIER_swigconstant(_almathinternal)
BEZIER = _almathinternal.BEZIER

_almathinternal.BEZIER_AUTO_swigconstant(_almathinternal)
BEZIER_AUTO = _almathinternal.BEZIER_AUTO
class Tangent(_object):
    """Proxy of C++ AL::Math::Interpolation::Tangent class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tangent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Tangent, name)
    __swig_setmethods__["fType"] = _almathinternal.Tangent_fType_set
    __swig_getmethods__["fType"] = _almathinternal.Tangent_fType_get
    if _newclass:
        fType = _swig_property(_almathinternal.Tangent_fType_get, _almathinternal.Tangent_fType_set)
    __swig_setmethods__["fOffset"] = _almathinternal.Tangent_fOffset_set
    __swig_getmethods__["fOffset"] = _almathinternal.Tangent_fOffset_get
    if _newclass:
        fOffset = _swig_property(_almathinternal.Tangent_fOffset_get, _almathinternal.Tangent_fOffset_set)

    def __init__(self, *args):
        """
        __init__(AL::Math::Interpolation::Tangent self) -> Tangent
        __init__(AL::Math::Interpolation::Tangent self, AL::Math::Interpolation::InterpolationType pType, Position2D pOffset) -> Tangent
        """
        this = _almathinternal.new_Tangent(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def isNear(self, pTan2, pEpsilon=0.0001):
        """
        isNear(Tangent self, Tangent pTan2, float const & pEpsilon=0.0001) -> bool
        isNear(Tangent self, Tangent pTan2) -> bool
        """
        return _almathinternal.Tangent_isNear(self, pTan2, pEpsilon)


    def __repr__(self):
        """__repr__(Tangent self) -> char *"""
        return _almathinternal.Tangent___repr__(self)

    __swig_destroy__ = _almathinternal.delete_Tangent
    __del__ = lambda self: None
Tangent_swigregister = _almathinternal.Tangent_swigregister
Tangent_swigregister(Tangent)

class Key(_object):
    """Proxy of C++ AL::Math::Interpolation::Key class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Key, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Key, name)
    __swig_setmethods__["fValue"] = _almathinternal.Key_fValue_set
    __swig_getmethods__["fValue"] = _almathinternal.Key_fValue_get
    if _newclass:
        fValue = _swig_property(_almathinternal.Key_fValue_get, _almathinternal.Key_fValue_set)
    __swig_setmethods__["fLeftTangent"] = _almathinternal.Key_fLeftTangent_set
    __swig_getmethods__["fLeftTangent"] = _almathinternal.Key_fLeftTangent_get
    if _newclass:
        fLeftTangent = _swig_property(_almathinternal.Key_fLeftTangent_get, _almathinternal.Key_fLeftTangent_set)
    __swig_setmethods__["fRightTangent"] = _almathinternal.Key_fRightTangent_set
    __swig_getmethods__["fRightTangent"] = _almathinternal.Key_fRightTangent_get
    if _newclass:
        fRightTangent = _swig_property(_almathinternal.Key_fRightTangent_get, _almathinternal.Key_fRightTangent_set)

    def __init__(self, *args):
        """
        __init__(AL::Math::Interpolation::Key self) -> Key
        __init__(AL::Math::Interpolation::Key self, float const & pValue, Tangent pLeftTangent, Tangent pRightTangent) -> Key
        """
        this = _almathinternal.new_Key(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def isNear(self, pTan2, pEpsilon=0.0001):
        """
        isNear(Key self, Key pTan2, float const & pEpsilon=0.0001) -> bool
        isNear(Key self, Key pTan2) -> bool
        """
        return _almathinternal.Key_isNear(self, pTan2, pEpsilon)


    def __repr__(self):
        """__repr__(Key self) -> char *"""
        return _almathinternal.Key___repr__(self)

    __swig_destroy__ = _almathinternal.delete_Key
    __del__ = lambda self: None
Key_swigregister = _almathinternal.Key_swigregister
Key_swigregister(Key)


def __lshift__(*args):
    """
    __lshift__(std::ostream & pStream, Tangent p) -> std::ostream
    __lshift__(std::ostream & pStream, Key p) -> std::ostream
    __lshift__(std::ostream & pStream, AL::Math::Interpolation::TALJointCommandPair const & p) -> std::ostream
    __lshift__(std::ostream & pStream, AL::Math::Interpolation::TALJointCommandVector const & p) -> std::ostream &
    """
    return _almathinternal.__lshift__(*args)

def checkVelocityMax(pVector, pStartAngle, pMaxVelocity):
    """checkVelocityMax(AL::Math::Interpolation::TALJointCommandVector const & pVector, float const & pStartAngle, float const & pMaxVelocity) -> float"""
    return _almathinternal.checkVelocityMax(pVector, pStartAngle, pMaxVelocity)
class ALInterpolationBezier(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationBezier class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationBezier, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationBezier, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(AL::Math::Interpolation::ALInterpolationBezier self) -> ALInterpolationBezier"""
        this = _almathinternal.new_ALInterpolationBezier()
        try:
            self.this.append(this)
        except:
            self.this = this

    def interpolate(self, *args):
        """
        interpolate(ALInterpolationBezier self, float pDuration, Key pFromKey, Key pToKey, float pMinValue, float pMaxValue, float pValueIncrementLimit, float pDt) -> vectorFloat
        interpolate(ALInterpolationBezier self, Position2D pP0, Position2D pP1, Position2D pP2, Position2D pP3, float pDt) -> vectorFloat
        """
        return _almathinternal.ALInterpolationBezier_interpolate(self, *args)


    def interpolatePos(self, pP0, pP1, pP2, pP3, pDt):
        """interpolatePos(ALInterpolationBezier self, Position2D pP0, Position2D pP1, Position2D pP2, Position2D pP3, float pDt) -> vectorFloat"""
        return _almathinternal.ALInterpolationBezier_interpolatePos(self, pP0, pP1, pP2, pP3, pDt)


    def interpolateVel(self, pP0, pP1, pP2, pP3, pDt):
        """interpolateVel(ALInterpolationBezier self, Position2D pP0, Position2D pP1, Position2D pP2, Position2D pP3, float pDt) -> vectorFloat"""
        return _almathinternal.ALInterpolationBezier_interpolateVel(self, pP0, pP1, pP2, pP3, pDt)


    def getNextPosition(self):
        """getNextPosition(ALInterpolationBezier self) -> float"""
        return _almathinternal.ALInterpolationBezier_getNextPosition(self)


    def getNextPositionVelocity(self, *args):
        """
        getNextPositionVelocity(ALInterpolationBezier self, PositionAndVelocity pSol)
        getNextPositionVelocity(ALInterpolationBezier self) -> PositionAndVelocity
        """
        return _almathinternal.ALInterpolationBezier_getNextPositionVelocity(self, *args)


    def isFinished(self):
        """isFinished(ALInterpolationBezier self) -> bool"""
        return _almathinternal.ALInterpolationBezier_isFinished(self)


    def setIsFinished(self, pIsFinished):
        """setIsFinished(ALInterpolationBezier self, bool pIsFinished)"""
        return _almathinternal.ALInterpolationBezier_setIsFinished(self, pIsFinished)

    __swig_destroy__ = _almathinternal.delete_ALInterpolationBezier
    __del__ = lambda self: None

    def init(self, *args):
        """
        init(ALInterpolationBezier self, float pDuration, Key pFromKey, Key pToKey, float pMinValue, float pMaxValue, float pValueIncrementLimit, float pDt)
        init(ALInterpolationBezier self, float pDuration, Key pFromKey, Key pToKey, float pPeriod)
        """
        return _almathinternal.ALInterpolationBezier_init(self, *args)


    def getCurrentInterpolation(self, pTime, pOrder, pInterpolationResult):
        """getCurrentInterpolation(ALInterpolationBezier self, float pTime, unsigned int pOrder, vectorFloat pInterpolationResult)"""
        return _almathinternal.ALInterpolationBezier_getCurrentInterpolation(self, pTime, pOrder, pInterpolationResult)

ALInterpolationBezier_swigregister = _almathinternal.ALInterpolationBezier_swigregister
ALInterpolationBezier_swigregister(ALInterpolationBezier)


def getBezierPolynoms(pS, pOrder, pResultCoefficients):
    """getBezierPolynoms(float pS, unsigned int pOrder, vectorFloat pResultCoefficients)"""
    return _almathinternal.getBezierPolynoms(pS, pOrder, pResultCoefficients)
class BezierCurve(_object):
    """Proxy of C++ AL::Math::Interpolation::BezierCurve class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BezierCurve, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BezierCurve, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(AL::Math::Interpolation::BezierCurve self) -> BezierCurve"""
        this = _almathinternal.new_BezierCurve()
        try:
            self.this.append(this)
        except:
            self.this = this

    def getBezierY(self, pP0, pP1, pP2, pP3, pS):
        """getBezierY(BezierCurve self, Position2D pP0, Position2D pP1, Position2D pP2, Position2D pP3, float pS) -> float"""
        return _almathinternal.BezierCurve_getBezierY(self, pP0, pP1, pP2, pP3, pS)


    def getBezierPosition(self, pP0, pP1, pP2, pP3, pS, pPositionResult):
        """getBezierPosition(BezierCurve self, Position2D pP0, Position2D pP1, Position2D pP2, Position2D pP3, float pS, Position2D pPositionResult)"""
        return _almathinternal.BezierCurve_getBezierPosition(self, pP0, pP1, pP2, pP3, pS, pPositionResult)


    def getBezierPositionAndTangent(self, pP0, pP1, pP2, pP3, pS, pPositionResult, pTangentResult):
        """getBezierPositionAndTangent(BezierCurve self, Position2D pP0, Position2D pP1, Position2D pP2, Position2D pP3, float pS, Position2D pPositionResult, Position2D pTangentResult)"""
        return _almathinternal.BezierCurve_getBezierPositionAndTangent(self, pP0, pP1, pP2, pP3, pS, pPositionResult, pTangentResult)

    __swig_destroy__ = _almathinternal.delete_BezierCurve
    __del__ = lambda self: None
BezierCurve_swigregister = _almathinternal.BezierCurve_swigregister
BezierCurve_swigregister(BezierCurve)


def computeNumberSamples(pP0, pP3, pDt):
    """computeNumberSamples(Position2D pP0, Position2D pP3, float pDt) -> unsigned int"""
    return _almathinternal.computeNumberSamples(pP0, pP3, pDt)

def computePolygonValue(pP0, pP1, pP2, pP3, pA, pB, pC):
    """computePolygonValue(Position2D pP0, Position2D pP1, Position2D pP2, Position2D pP3, float & pA, float & pB, float & pC)"""
    return _almathinternal.computePolygonValue(pP0, pP1, pP2, pP3, pA, pB, pC)

def getCurrentParameter(pA, pB, pC, pTime, pLastParameter):
    """getCurrentParameter(float pA, float pB, float pC, float pTime, float & pLastParameter) -> float"""
    return _almathinternal.getCurrentParameter(pA, pB, pC, pTime, pLastParameter)

def updateBezierAutoTangents(pCurrentIndex, pKey, pLeftIndex, pLeftNeighbor, pRightIndex, pRightNeighbor):
    """updateBezierAutoTangents(int pCurrentIndex, Key pKey, int pLeftIndex, Key pLeftNeighbor, int pRightIndex, Key pRightNeighbor) -> bool"""
    return _almathinternal.updateBezierAutoTangents(pCurrentIndex, pKey, pLeftIndex, pLeftNeighbor, pRightIndex, pRightNeighbor)
class ALInterpolationArticular(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationArticular class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationArticular, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationArticular, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(AL::Math::Interpolation::ALInterpolationArticular self) -> ALInterpolationArticular"""
        this = _almathinternal.new_ALInterpolationArticular()
        try:
            self.this.append(this)
        except:
            self.this = this

    def init(self, *args):
        """
        init(ALInterpolationArticular self, vectorFloat pTime, vectorFloat pPoint, float const & pPeriod)
        init(ALInterpolationArticular self, float const & pTimeInit, float const & pTimeFinal, float const & pPointInit, float const & pPointFinal, float const & pVelocityInit, float const & pVelocityFinal, float const & pVelocityMaxAbs, bool const & pChangeTimeFinal, float const & pPeriod)
        init(ALInterpolationArticular self, float const & pTimeInit, float const & pTimeFinal, float const & pPointInit, float const & pPointFinal, float const & pVelocityInit, float const & pVelocityFinal, float const & pPeriod)
        init(ALInterpolationArticular self, vectorFloat pTime, vectorFloat pPoint, vectorFloat pVelocity, bool const & pIsHotStart, float const & pPeriod)
        """
        return _almathinternal.ALInterpolationArticular_init(self, *args)


    def getCurrentInterpolation(self, *args):
        """
        getCurrentInterpolation(ALInterpolationArticular self, float const & pTimeCurrent, PositionAndVelocity pOut)
        getCurrentInterpolation(ALInterpolationArticular self, float const & pTimeCurrent) -> PositionAndVelocity
        """
        return _almathinternal.ALInterpolationArticular_getCurrentInterpolation(self, *args)


    def getAllInterpolation(self, dt_step):
        """getAllInterpolation(ALInterpolationArticular self, float const & dt_step) -> std::vector< AL::Math::PositionAndVelocity,std::allocator< AL::Math::PositionAndVelocity > >"""
        return _almathinternal.ALInterpolationArticular_getAllInterpolation(self, dt_step)


    def isFinished(self, time):
        """isFinished(ALInterpolationArticular self, float const & time) -> bool"""
        return _almathinternal.ALInterpolationArticular_isFinished(self, time)


    def setIsFinished(self, pIsFinished):
        """setIsFinished(ALInterpolationArticular self, bool pIsFinished)"""
        return _almathinternal.ALInterpolationArticular_setIsFinished(self, pIsFinished)


    def getNumTimesCalled(self):
        """getNumTimesCalled(ALInterpolationArticular self) -> unsigned int"""
        return _almathinternal.ALInterpolationArticular_getNumTimesCalled(self)

    __swig_destroy__ = _almathinternal.delete_ALInterpolationArticular
    __del__ = lambda self: None
ALInterpolationArticular_swigregister = _almathinternal.ALInterpolationArticular_swigregister
ALInterpolationArticular_swigregister(ALInterpolationArticular)

class ALInterpolationArticular3D(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationArticular3D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationArticular3D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationArticular3D, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(AL::Math::Interpolation::ALInterpolationArticular3D self) -> ALInterpolationArticular3D"""
        this = _almathinternal.new_ALInterpolationArticular3D()
        try:
            self.this.append(this)
        except:
            self.this = this

    def init(self, pTimeInit, pTimeFinal, pPointInit, pPointFinal, pVelocityInit, pVelocityFinal, pPeriod):
        """init(ALInterpolationArticular3D self, float const & pTimeInit, float const & pTimeFinal, Pose2D pPointInit, Pose2D pPointFinal, Pose2D pVelocityInit, Pose2D pVelocityFinal, float const & pPeriod)"""
        return _almathinternal.ALInterpolationArticular3D_init(self, pTimeInit, pTimeFinal, pPointInit, pPointFinal, pVelocityInit, pVelocityFinal, pPeriod)


    def getCurrentInterpolation(self, pTimeCurrent, pPoint, pVelocity):
        """getCurrentInterpolation(ALInterpolationArticular3D self, float const & pTimeCurrent, Pose2D pPoint, Pose2D pVelocity)"""
        return _almathinternal.ALInterpolationArticular3D_getCurrentInterpolation(self, pTimeCurrent, pPoint, pVelocity)


    def isFinished(self, time):
        """isFinished(ALInterpolationArticular3D self, float const & time) -> bool"""
        return _almathinternal.ALInterpolationArticular3D_isFinished(self, time)

    __swig_destroy__ = _almathinternal.delete_ALInterpolationArticular3D
    __del__ = lambda self: None
ALInterpolationArticular3D_swigregister = _almathinternal.ALInterpolationArticular3D_swigregister
ALInterpolationArticular3D_swigregister(ALInterpolationArticular3D)

class InterpolationTrapezoid(_object):
    """Proxy of C++ AL::Math::Interpolation::InterpolationTrapezoid class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterpolationTrapezoid, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InterpolationTrapezoid, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(AL::Math::Interpolation::InterpolationTrapezoid self) -> InterpolationTrapezoid"""
        this = _almathinternal.new_InterpolationTrapezoid()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _almathinternal.delete_InterpolationTrapezoid
    __del__ = lambda self: None

    def getSmoothTrapezoid(self, *args):
        """
        getSmoothTrapezoid(InterpolationTrapezoid self, unsigned int const & pNumSamples, float const & pHeight, unsigned int const & pAttack, unsigned int const & pDecay, vectorFloat pVectorResult)
        getSmoothTrapezoid(InterpolationTrapezoid self, unsigned int const & pNumSamples, float const & pHeight, unsigned int const & pAttack, unsigned int const & pDecay) -> vectorFloat
        """
        return _almathinternal.InterpolationTrapezoid_getSmoothTrapezoid(self, *args)

InterpolationTrapezoid_swigregister = _almathinternal.InterpolationTrapezoid_swigregister
InterpolationTrapezoid_swigregister(InterpolationTrapezoid)

class ALInterpolationTrapezoidalAcceleration(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationTrapezoidalAcceleration class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationTrapezoidalAcceleration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationTrapezoidalAcceleration, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(AL::Math::Interpolation::ALInterpolationTrapezoidalAcceleration self) -> ALInterpolationTrapezoidalAcceleration"""
        this = _almathinternal.new_ALInterpolationTrapezoidalAcceleration()
        try:
            self.this.append(this)
        except:
            self.this = this

    def init(self, *args):
        """
        init(ALInterpolationTrapezoidalAcceleration self, float const & pVelocityInit, float const & pVelocityFinal, float const & pVelocityMaxAbs, float const & pAccelerationInit, float const & pAccelerationMaxAbs, float const & pJerkMaxAbs, float const & pPeriod)
        init(ALInterpolationTrapezoidalAcceleration self, VelAcc pStateInit, float pVelocityFinal, Limits pLimits, float pPeriod)
        """
        return _almathinternal.ALInterpolationTrapezoidalAcceleration_init(self, *args)


    def getCurrentInterpolation(self, *args):
        """
        getCurrentInterpolation(ALInterpolationTrapezoidalAcceleration self, float pTime) -> VelAcc
        getCurrentInterpolation(ALInterpolationTrapezoidalAcceleration self, float pTime, VelAcc pResultVelAcc)
        """
        return _almathinternal.ALInterpolationTrapezoidalAcceleration_getCurrentInterpolation(self, *args)


    def getCurrentJerk(self, pTime):
        """getCurrentJerk(ALInterpolationTrapezoidalAcceleration self, float pTime) -> float"""
        return _almathinternal.ALInterpolationTrapezoidalAcceleration_getCurrentJerk(self, pTime)


    def getFinalTime(self):
        """getFinalTime(ALInterpolationTrapezoidalAcceleration self) -> float"""
        return _almathinternal.ALInterpolationTrapezoidalAcceleration_getFinalTime(self)


    def setFinalTime(self, pFinalTime):
        """setFinalTime(ALInterpolationTrapezoidalAcceleration self, float const & pFinalTime)"""
        return _almathinternal.ALInterpolationTrapezoidalAcceleration_setFinalTime(self, pFinalTime)

    __swig_destroy__ = _almathinternal.delete_ALInterpolationTrapezoidalAcceleration
    __del__ = lambda self: None
ALInterpolationTrapezoidalAcceleration_swigregister = _almathinternal.ALInterpolationTrapezoidalAcceleration_swigregister
ALInterpolationTrapezoidalAcceleration_swigregister(ALInterpolationTrapezoidalAcceleration)


_almathinternal.TRAPEZOIDSMOOTH_STATE_FINISHED_swigconstant(_almathinternal)
TRAPEZOIDSMOOTH_STATE_FINISHED = _almathinternal.TRAPEZOIDSMOOTH_STATE_FINISHED

_almathinternal.TRAPEZOIDSMOOTH_STATE_INIT_swigconstant(_almathinternal)
TRAPEZOIDSMOOTH_STATE_INIT = _almathinternal.TRAPEZOIDSMOOTH_STATE_INIT

_almathinternal.TRAPEZOIDSMOOTH_STATE_MID_swigconstant(_almathinternal)
TRAPEZOIDSMOOTH_STATE_MID = _almathinternal.TRAPEZOIDSMOOTH_STATE_MID

_almathinternal.TRAPEZOIDSMOOTH_STATE_END_swigconstant(_almathinternal)
TRAPEZOIDSMOOTH_STATE_END = _almathinternal.TRAPEZOIDSMOOTH_STATE_END

_almathinternal.TRAPEZOIDSMOOTH_STATE_SIZE_swigconstant(_almathinternal)
TRAPEZOIDSMOOTH_STATE_SIZE = _almathinternal.TRAPEZOIDSMOOTH_STATE_SIZE
class InterpolationTrapezoidSmooth(_object):
    """Proxy of C++ AL::Math::Interpolation::InterpolationTrapezoidSmooth class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterpolationTrapezoidSmooth, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InterpolationTrapezoidSmooth, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AL::Math::Interpolation::InterpolationTrapezoidSmooth self) -> InterpolationTrapezoidSmooth
        __init__(AL::Math::Interpolation::InterpolationTrapezoidSmooth self, float const & pPeriod, unsigned int const & pNbStepMid, float const & pVelocityMax, float const & pAccelerationMax) -> InterpolationTrapezoidSmooth
        __init__(AL::Math::Interpolation::InterpolationTrapezoidSmooth self, float const & pPeriod, unsigned int const & pNbStepMid, float const & pVelocityMax, float const & pAccelerationMax, float const & pHeightMid, float const & pHeightEnd) -> InterpolationTrapezoidSmooth
        """
        this = _almathinternal.new_InterpolationTrapezoidSmooth(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _almathinternal.delete_InterpolationTrapezoidSmooth
    __del__ = lambda self: None

    def getAllInterpolation(self, *args):
        """
        getAllInterpolation(InterpolationTrapezoidSmooth self, vectorFloat pResult)
        getAllInterpolation(InterpolationTrapezoidSmooth self) -> vectorFloat
        """
        return _almathinternal.InterpolationTrapezoidSmooth_getAllInterpolation(self, *args)


    def init(self, pHeightMid, pHeightEnd):
        """init(InterpolationTrapezoidSmooth self, float const & pHeightMid, float const & pHeightEnd)"""
        return _almathinternal.InterpolationTrapezoidSmooth_init(self, pHeightMid, pHeightEnd)


    def restart(self):
        """restart(InterpolationTrapezoidSmooth self)"""
        return _almathinternal.InterpolationTrapezoidSmooth_restart(self)


    def getNextPosition(self):
        """getNextPosition(InterpolationTrapezoidSmooth self) -> float"""
        return _almathinternal.InterpolationTrapezoidSmooth_getNextPosition(self)


    def isFinished(self):
        """isFinished(InterpolationTrapezoidSmooth self) -> bool"""
        return _almathinternal.InterpolationTrapezoidSmooth_isFinished(self)

InterpolationTrapezoidSmooth_swigregister = _almathinternal.InterpolationTrapezoidSmooth_swigregister
InterpolationTrapezoidSmooth_swigregister(InterpolationTrapezoidSmooth)

class ALInterpolationTypeIV(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationTypeIV class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationTypeIV, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationTypeIV, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(AL::Math::Interpolation::ALInterpolationTypeIV self) -> ALInterpolationTypeIV"""
        this = _almathinternal.new_ALInterpolationTypeIV()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _almathinternal.delete_ALInterpolationTypeIV
    __del__ = lambda self: None

    def init(self, *args):
        """
        init(ALInterpolationTypeIV self, PosVelAcc pInitialCondition, float const & pFinalPosition, float const & pFinalVelocity, Limits pLimits, float const & pPeriod, float const & pFinalTime)
        init(ALInterpolationTypeIV self, PosVelAcc pInitialCondition, float const & pFinalPosition, float const & pFinalVelocity, Limits pLimits, float const & pPeriod, bool const & pIsExact=False)
        init(ALInterpolationTypeIV self, PosVelAcc pInitialCondition, float const & pFinalPosition, float const & pFinalVelocity, Limits pLimits, float const & pPeriod)
        """
        return _almathinternal.ALInterpolationTypeIV_init(self, *args)


    def setFinalTime(self, pFinalTime):
        """setFinalTime(ALInterpolationTypeIV self, float pFinalTime)"""
        return _almathinternal.ALInterpolationTypeIV_setFinalTime(self, pFinalTime)


    def getCurrentInterpolation(self, pTime):
        """getCurrentInterpolation(ALInterpolationTypeIV self, float const & pTime) -> PosVelAcc"""
        return _almathinternal.ALInterpolationTypeIV_getCurrentInterpolation(self, pTime)


    def getAllPositions(self):
        """getAllPositions(ALInterpolationTypeIV self) -> vectorFloat"""
        return _almathinternal.ALInterpolationTypeIV_getAllPositions(self)


    def getAllInterpolations(self):
        """getAllInterpolations(ALInterpolationTypeIV self) -> std::vector< AL::Math::PosVelAcc,std::allocator< AL::Math::PosVelAcc > >"""
        return _almathinternal.ALInterpolationTypeIV_getAllInterpolations(self)


    def getFinalTime(self):
        """getFinalTime(ALInterpolationTypeIV self) -> float"""
        return _almathinternal.ALInterpolationTypeIV_getFinalTime(self)


    def getMinimumTime(self):
        """getMinimumTime(ALInterpolationTypeIV self) -> float"""
        return _almathinternal.ALInterpolationTypeIV_getMinimumTime(self)


    def getInoperativeInterval(self):
        """getInoperativeInterval(ALInterpolationTypeIV self) -> std::pair< float,float >"""
        return _almathinternal.ALInterpolationTypeIV_getInoperativeInterval(self)

ALInterpolationTypeIV_swigregister = _almathinternal.ALInterpolationTypeIV_swigregister
ALInterpolationTypeIV_swigregister(ALInterpolationTypeIV)

class ALInterpolationTypeIV3D(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationTypeIV3D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationTypeIV3D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationTypeIV3D, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(AL::Math::Interpolation::ALInterpolationTypeIV3D self) -> ALInterpolationTypeIV3D"""
        this = _almathinternal.new_ALInterpolationTypeIV3D()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _almathinternal.delete_ALInterpolationTypeIV3D
    __del__ = lambda self: None

    def init(self, *args):
        """
        init(ALInterpolationTypeIV3D self, Pose2D pPointInit, Pose2D pPointFinal, Pose2D pVelocityInit, Pose2D pVelocityFinal, Pose2D pAccelerationInit, Limits pLimitsXY, Limits pLimitsTheta, float const & pPeriod)
        init(ALInterpolationTypeIV3D self, Pose2D pPointInit, Pose2D pPointFinal, Pose2D pVelocityInit, Pose2D pVelocityFinal, Pose2D pAccelerationInit, Limits pLimitsXY, Limits pLimitsTheta, float const & pFinalTime, float const & pPeriod)
        """
        return _almathinternal.ALInterpolationTypeIV3D_init(self, *args)


    def getCurrentInterpolation(self, pTimeCurrent, pPoint, pVelocity, pAcceleration):
        """getCurrentInterpolation(ALInterpolationTypeIV3D self, float const & pTimeCurrent, Pose2D pPoint, Pose2D pVelocity, Pose2D pAcceleration)"""
        return _almathinternal.ALInterpolationTypeIV3D_getCurrentInterpolation(self, pTimeCurrent, pPoint, pVelocity, pAcceleration)


    def getFinalTime(self):
        """getFinalTime(ALInterpolationTypeIV3D self) -> float"""
        return _almathinternal.ALInterpolationTypeIV3D_getFinalTime(self)

ALInterpolationTypeIV3D_swigregister = _almathinternal.ALInterpolationTypeIV3D_swigregister
ALInterpolationTypeIV3D_swigregister(ALInterpolationTypeIV3D)

class ALInterpolationQuinticSpline(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationQuinticSpline class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationQuinticSpline, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationQuinticSpline, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(AL::Math::Interpolation::ALInterpolationQuinticSpline self) -> ALInterpolationQuinticSpline"""
        this = _almathinternal.new_ALInterpolationQuinticSpline()
        try:
            self.this.append(this)
        except:
            self.this = this

    def init(self, pLimits, pInitialCondition, pFinaleCondition, pPeriod):
        """init(ALInterpolationQuinticSpline self, Limits pLimits, PosVelAcc pInitialCondition, PosVelAcc pFinaleCondition, float const & pPeriod)"""
        return _almathinternal.ALInterpolationQuinticSpline_init(self, pLimits, pInitialCondition, pFinaleCondition, pPeriod)


    def getCurrentInterpolation(self, pTime):
        """getCurrentInterpolation(ALInterpolationQuinticSpline self, float const & pTime) -> PosVelAcc"""
        return _almathinternal.ALInterpolationQuinticSpline_getCurrentInterpolation(self, pTime)


    def getFinalTime(self):
        """getFinalTime(ALInterpolationQuinticSpline self) -> float"""
        return _almathinternal.ALInterpolationQuinticSpline_getFinalTime(self)


    def getMinimumTime(self):
        """getMinimumTime(ALInterpolationQuinticSpline self) -> float"""
        return _almathinternal.ALInterpolationQuinticSpline_getMinimumTime(self)


    def setFinalTime(self, pFinalTime):
        """setFinalTime(ALInterpolationQuinticSpline self, float const & pFinalTime)"""
        return _almathinternal.ALInterpolationQuinticSpline_setFinalTime(self, pFinalTime)


    def isFinished(self, pTime):
        """isFinished(ALInterpolationQuinticSpline self, float const & pTime) -> bool"""
        return _almathinternal.ALInterpolationQuinticSpline_isFinished(self, pTime)

    __swig_destroy__ = _almathinternal.delete_ALInterpolationQuinticSpline
    __del__ = lambda self: None
ALInterpolationQuinticSpline_swigregister = _almathinternal.ALInterpolationQuinticSpline_swigregister
ALInterpolationQuinticSpline_swigregister(ALInterpolationQuinticSpline)

class ALInterpolationBangBangAcceleration(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationBangBangAcceleration class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationBangBangAcceleration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationBangBangAcceleration, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(AL::Math::Interpolation::ALInterpolationBangBangAcceleration self) -> ALInterpolationBangBangAcceleration"""
        this = _almathinternal.new_ALInterpolationBangBangAcceleration()
        try:
            self.this.append(this)
        except:
            self.this = this

    def init(self, pPositionInit, pPositionFinal, pVelocityInit, pLimits, pPeriod):
        """init(ALInterpolationBangBangAcceleration self, float pPositionInit, float pPositionFinal, float pVelocityInit, Limits pLimits, float pPeriod)"""
        return _almathinternal.ALInterpolationBangBangAcceleration_init(self, pPositionInit, pPositionFinal, pVelocityInit, pLimits, pPeriod)


    def getCurrentInterpolation(self, *args):
        """
        getCurrentInterpolation(ALInterpolationBangBangAcceleration self, float pTime, PosVelAcc pResult)
        getCurrentInterpolation(ALInterpolationBangBangAcceleration self, float pTime) -> PosVelAcc
        """
        return _almathinternal.ALInterpolationBangBangAcceleration_getCurrentInterpolation(self, *args)


    def getFinalTime(self):
        """getFinalTime(ALInterpolationBangBangAcceleration self) -> float"""
        return _almathinternal.ALInterpolationBangBangAcceleration_getFinalTime(self)


    def getMinimumTime(self):
        """getMinimumTime(ALInterpolationBangBangAcceleration self) -> float"""
        return _almathinternal.ALInterpolationBangBangAcceleration_getMinimumTime(self)


    def setFinalTime(self, pFinalTime):
        """setFinalTime(ALInterpolationBangBangAcceleration self, float pFinalTime)"""
        return _almathinternal.ALInterpolationBangBangAcceleration_setFinalTime(self, pFinalTime)

    __swig_destroy__ = _almathinternal.delete_ALInterpolationBangBangAcceleration
    __del__ = lambda self: None
ALInterpolationBangBangAcceleration_swigregister = _almathinternal.ALInterpolationBangBangAcceleration_swigregister
ALInterpolationBangBangAcceleration_swigregister(ALInterpolationBangBangAcceleration)

class Limits(_object):
    """Proxy of C++ AL::Math::Limits class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Limits, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Limits, name)
    __repr__ = _swig_repr
    __swig_setmethods__["maxJerk"] = _almathinternal.Limits_maxJerk_set
    __swig_getmethods__["maxJerk"] = _almathinternal.Limits_maxJerk_get
    if _newclass:
        maxJerk = _swig_property(_almathinternal.Limits_maxJerk_get, _almathinternal.Limits_maxJerk_set)
    __swig_setmethods__["maxAcc"] = _almathinternal.Limits_maxAcc_set
    __swig_getmethods__["maxAcc"] = _almathinternal.Limits_maxAcc_get
    if _newclass:
        maxAcc = _swig_property(_almathinternal.Limits_maxAcc_get, _almathinternal.Limits_maxAcc_set)
    __swig_setmethods__["maxVel"] = _almathinternal.Limits_maxVel_set
    __swig_getmethods__["maxVel"] = _almathinternal.Limits_maxVel_get
    if _newclass:
        maxVel = _swig_property(_almathinternal.Limits_maxVel_get, _almathinternal.Limits_maxVel_set)

    def __init__(self, *args):
        """
        __init__(AL::Math::Limits self) -> Limits
        __init__(AL::Math::Limits self, float const & pMaxJerk, float const & pMaxAcc, float const & pMaxVel) -> Limits
        """
        this = _almathinternal.new_Limits(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _almathinternal.delete_Limits
    __del__ = lambda self: None
Limits_swigregister = _almathinternal.Limits_swigregister
Limits_swigregister(Limits)


def checkLimits(pLimits, pEpsilon):
    """checkLimits(Limits pLimits, float const pEpsilon) -> bool"""
    return _almathinternal.checkLimits(pLimits, pEpsilon)
class PosVelAcc(_object):
    """Proxy of C++ AL::Math::PosVelAcc class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PosVelAcc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PosVelAcc, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _almathinternal.PosVelAcc_x_set
    __swig_getmethods__["x"] = _almathinternal.PosVelAcc_x_get
    if _newclass:
        x = _swig_property(_almathinternal.PosVelAcc_x_get, _almathinternal.PosVelAcc_x_set)
    __swig_setmethods__["dx"] = _almathinternal.PosVelAcc_dx_set
    __swig_getmethods__["dx"] = _almathinternal.PosVelAcc_dx_get
    if _newclass:
        dx = _swig_property(_almathinternal.PosVelAcc_dx_get, _almathinternal.PosVelAcc_dx_set)
    __swig_setmethods__["ddx"] = _almathinternal.PosVelAcc_ddx_set
    __swig_getmethods__["ddx"] = _almathinternal.PosVelAcc_ddx_get
    if _newclass:
        ddx = _swig_property(_almathinternal.PosVelAcc_ddx_get, _almathinternal.PosVelAcc_ddx_set)

    def __init__(self, px=0.0, pdx=0.0, pddx=0.0):
        """
        __init__(AL::Math::PosVelAcc self, float const px=0.0, float const pdx=0.0, float const pddx=0.0) -> PosVelAcc
        __init__(AL::Math::PosVelAcc self, float const px=0.0, float const pdx=0.0) -> PosVelAcc
        __init__(AL::Math::PosVelAcc self, float const px=0.0) -> PosVelAcc
        __init__(AL::Math::PosVelAcc self) -> PosVelAcc
        """
        this = _almathinternal.new_PosVelAcc(px, pdx, pddx)
        try:
            self.this.append(this)
        except:
            self.this = this

    def __add__(self, pPos2):
        """__add__(PosVelAcc self, PosVelAcc pPos2) -> PosVelAcc"""
        return _almathinternal.PosVelAcc___add__(self, pPos2)


    def __sub__(self, pPos2):
        """__sub__(PosVelAcc self, PosVelAcc pPos2) -> PosVelAcc"""
        return _almathinternal.PosVelAcc___sub__(self, pPos2)


    def __pos__(self):
        """__pos__(PosVelAcc self) -> PosVelAcc"""
        return _almathinternal.PosVelAcc___pos__(self)


    def __neg__(self):
        """__neg__(PosVelAcc self) -> PosVelAcc"""
        return _almathinternal.PosVelAcc___neg__(self)


    def __iadd__(self, pPos2):
        """__iadd__(PosVelAcc self, PosVelAcc pPos2) -> PosVelAcc"""
        return _almathinternal.PosVelAcc___iadd__(self, pPos2)


    def __isub__(self, pPos2):
        """__isub__(PosVelAcc self, PosVelAcc pPos2) -> PosVelAcc"""
        return _almathinternal.PosVelAcc___isub__(self, pPos2)


    def isNear(self, pDat2, pEpsilon=0.0001):
        """
        isNear(PosVelAcc self, PosVelAcc pDat2, float const & pEpsilon=0.0001) -> bool
        isNear(PosVelAcc self, PosVelAcc pDat2) -> bool
        """
        return _almathinternal.PosVelAcc_isNear(self, pDat2, pEpsilon)

    __swig_destroy__ = _almathinternal.delete_PosVelAcc
    __del__ = lambda self: None
PosVelAcc_swigregister = _almathinternal.PosVelAcc_swigregister
PosVelAcc_swigregister(PosVelAcc)

class Pose2DAndTime(_object):
    """Proxy of C++ AL::Math::Pose2DAndTime class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pose2DAndTime, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pose2DAndTime, name)
    __repr__ = _swig_repr
    __swig_setmethods__["pose2D"] = _almathinternal.Pose2DAndTime_pose2D_set
    __swig_getmethods__["pose2D"] = _almathinternal.Pose2DAndTime_pose2D_get
    if _newclass:
        pose2D = _swig_property(_almathinternal.Pose2DAndTime_pose2D_get, _almathinternal.Pose2DAndTime_pose2D_set)
    __swig_setmethods__["t"] = _almathinternal.Pose2DAndTime_t_set
    __swig_getmethods__["t"] = _almathinternal.Pose2DAndTime_t_get
    if _newclass:
        t = _swig_property(_almathinternal.Pose2DAndTime_t_get, _almathinternal.Pose2DAndTime_t_set)

    def __init__(self, *args):
        """
        __init__(AL::Math::Pose2DAndTime self, Pose2D pPose2D, float const pT=0.0) -> Pose2DAndTime
        __init__(AL::Math::Pose2DAndTime self, Pose2D pPose2D) -> Pose2DAndTime
        __init__(AL::Math::Pose2DAndTime self) -> Pose2DAndTime
        __init__(AL::Math::Pose2DAndTime self, float const pX, float const pY, float const pTheta, float const pT) -> Pose2DAndTime
        __init__(AL::Math::Pose2DAndTime self, vectorFloat pFloats) -> Pose2DAndTime
        """
        this = _almathinternal.new_Pose2DAndTime(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def isNear(self, pDat, pEpsilon=0.0001):
        """
        isNear(Pose2DAndTime self, Pose2DAndTime pDat, float const & pEpsilon=0.0001) -> bool
        isNear(Pose2DAndTime self, Pose2DAndTime pDat) -> bool
        """
        return _almathinternal.Pose2DAndTime_isNear(self, pDat, pEpsilon)


    def toVector(self, *args):
        """
        toVector(Pose2DAndTime self, vectorFloat pReturnVector)
        toVector(Pose2DAndTime self) -> vectorFloat
        """
        return _almathinternal.Pose2DAndTime_toVector(self, *args)

    __swig_destroy__ = _almathinternal.delete_Pose2DAndTime
    __del__ = lambda self: None
Pose2DAndTime_swigregister = _almathinternal.Pose2DAndTime_swigregister
Pose2DAndTime_swigregister(Pose2DAndTime)

class VelAcc(_object):
    """Proxy of C++ AL::Math::VelAcc class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VelAcc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VelAcc, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dq"] = _almathinternal.VelAcc_dq_set
    __swig_getmethods__["dq"] = _almathinternal.VelAcc_dq_get
    if _newclass:
        dq = _swig_property(_almathinternal.VelAcc_dq_get, _almathinternal.VelAcc_dq_set)
    __swig_setmethods__["ddq"] = _almathinternal.VelAcc_ddq_set
    __swig_getmethods__["ddq"] = _almathinternal.VelAcc_ddq_get
    if _newclass:
        ddq = _swig_property(_almathinternal.VelAcc_ddq_get, _almathinternal.VelAcc_ddq_set)

    def __init__(self, pdq=0.0, pddq=0.0):
        """
        __init__(AL::Math::VelAcc self, float const pdq=0.0, float const pddq=0.0) -> VelAcc
        __init__(AL::Math::VelAcc self, float const pdq=0.0) -> VelAcc
        __init__(AL::Math::VelAcc self) -> VelAcc
        """
        this = _almathinternal.new_VelAcc(pdq, pddq)
        try:
            self.this.append(this)
        except:
            self.this = this

    def isNear(self, pDat2, pEpsilon=0.0001):
        """
        isNear(VelAcc self, VelAcc pDat2, float const & pEpsilon=0.0001) -> bool
        isNear(VelAcc self, VelAcc pDat2) -> bool
        """
        return _almathinternal.VelAcc_isNear(self, pDat2, pEpsilon)

    __swig_destroy__ = _almathinternal.delete_VelAcc
    __del__ = lambda self: None
VelAcc_swigregister = _almathinternal.VelAcc_swigregister
VelAcc_swigregister(VelAcc)

class PosVelTime(_object):
    """Proxy of C++ AL::Math::PosVelTime class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PosVelTime, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PosVelTime, name)
    __repr__ = _swig_repr
    __swig_setmethods__["posVel"] = _almathinternal.PosVelTime_posVel_set
    __swig_getmethods__["posVel"] = _almathinternal.PosVelTime_posVel_get
    if _newclass:
        posVel = _swig_property(_almathinternal.PosVelTime_posVel_get, _almathinternal.PosVelTime_posVel_set)
    __swig_setmethods__["t"] = _almathinternal.PosVelTime_t_set
    __swig_getmethods__["t"] = _almathinternal.PosVelTime_t_get
    if _newclass:
        t = _swig_property(_almathinternal.PosVelTime_t_get, _almathinternal.PosVelTime_t_set)

    def __init__(self, *args):
        """
        __init__(AL::Math::PosVelTime self, PositionAndVelocity pPosVel, float const pT=0.0) -> PosVelTime
        __init__(AL::Math::PosVelTime self, PositionAndVelocity pPosVel) -> PosVelTime
        __init__(AL::Math::PosVelTime self) -> PosVelTime
        __init__(AL::Math::PosVelTime self, float const pq, float const pdq, float const pT) -> PosVelTime
        __init__(AL::Math::PosVelTime self, vectorFloat pFloats) -> PosVelTime
        """
        this = _almathinternal.new_PosVelTime(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def isNear(self, pDat, pEpsilon=0.0001):
        """
        isNear(PosVelTime self, PosVelTime pDat, float const & pEpsilon=0.0001) -> bool
        isNear(PosVelTime self, PosVelTime pDat) -> bool
        """
        return _almathinternal.PosVelTime_isNear(self, pDat, pEpsilon)


    def toVector(self, *args):
        """
        toVector(PosVelTime self, vectorFloat pReturnVector)
        toVector(PosVelTime self) -> vectorFloat
        """
        return _almathinternal.PosVelTime_toVector(self, *args)

    __swig_destroy__ = _almathinternal.delete_PosVelTime
    __del__ = lambda self: None
PosVelTime_swigregister = _almathinternal.PosVelTime_swigregister
PosVelTime_swigregister(PosVelTime)


def computePose2DTwoObject(pFirst, pSecond, pRes):
    """computePose2DTwoObject(Position3D pFirst, Position3D pSecond, Pose2D pRes)"""
    return _almathinternal.computePose2DTwoObject(pFirst, pSecond, pRes)

def computeFrameToObject(*args):
    """
    computeFrameToObject(Transform pFrameToCam, float const & pDistance, float const & pWy, float const & pWz, Position6D pResult)
    computeFrameToObject(Transform pFrameToCam, float const & pDistance, float const & pWy, float const & pWz) -> Position6D
    """
    return _almathinternal.computeFrameToObject(*args)

def computePointAtShoulderWy(*args):
    """
    computePointAtShoulderWy(Position3D pShoulderToObject, Transform pShoulderToElbow, float & pShoulderWy)
    computePointAtShoulderWy(Position3D pShoulderToObject, Transform pShoulderToElbow, vectorFloat pShoulderWy)
    """
    return _almathinternal.computePointAtShoulderWy(*args)

def computePointAtShoulderWz(*args):
    """
    computePointAtShoulderWz(Position3D pShoulderToObject, Transform pShoulderToElbow, float & pShoulderWz)
    computePointAtShoulderWz(Position3D pShoulderToObject, Transform pShoulderToElbow, vectorFloat pShoulderWz)
    """
    return _almathinternal.computePointAtShoulderWz(*args)

def computePointAtAnglesWyWz(pShoulderToObject, pShoulderToElbow, pShoulderWy, pShoulderWz):
    """computePointAtAnglesWyWz(Position3D pShoulderToObject, Position3D pShoulderToElbow, float & pShoulderWy, float & pShoulderWz)"""
    return _almathinternal.computePointAtAnglesWyWz(pShoulderToObject, pShoulderToElbow, pShoulderWy, pShoulderWz)

def oldComputePointAtAnglesWyWz(pShoulderToObject, pShoulderWy, pShoulderWz):
    """oldComputePointAtAnglesWyWz(Position3D pShoulderToObject, float & pShoulderWy, float & pShoulderWz)"""
    return _almathinternal.oldComputePointAtAnglesWyWz(pShoulderToObject, pShoulderWy, pShoulderWz)

def choosePointAtSolution(pShoulderToObject, pShoulderToElbow, pWySolution, pWzSolution0, pWzSolution1, pShoulderWy, pShoulderWz):
    """choosePointAtSolution(Position3D pShoulderToObject, Position3D pShoulderToElbow, vectorFloat pWySolution, vectorFloat pWzSolution0, vectorFloat pWzSolution1, float & pShoulderWy, float & pShoulderWz)"""
    return _almathinternal.choosePointAtSolution(pShoulderToObject, pShoulderToElbow, pWySolution, pWzSolution0, pWzSolution1, pShoulderWy, pShoulderWz)

def computeLookAtAngles(pTorsoToTarget, pTorsoToNeck, pNeckToEffector, pHeadWz, pHeadWy):
    """computeLookAtAngles(Position3D pTorsoToTarget, Position3D pTorsoToNeck, Transform pNeckToEffector, float & pHeadWz, float & pHeadWy) -> bool"""
    return _almathinternal.computeLookAtAngles(pTorsoToTarget, pTorsoToNeck, pNeckToEffector, pHeadWz, pHeadWy)
# This file is compatible with both classic and new-style classes.


